# 解析为什么 HashMap 的加载因子是 0.75

### 1.为什么 HashMap 需要负载因子

```
HashMap 的底层是哈希表,是存储键值对的结构类型,他需要通过一定的计算才可以确定数据在哈希表中的存储位置
```

源码 :

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
// AbstractMap
public int hashCode() {
     int h = 0;
     Iterator<Entry<K,V>> i = entrySet().iterator();
     while (i.hasNext())
         h += i.next().hashCode();

     return h;
}

```

```
一般的数据结构,不是查询快就是插入快,HashMap 就是一个插入慢,查询快的数据结构

这种数据结构会产生两种问题:
1. 如果空间利用率高,那么经过的哈希算法计算存储位置的时候,会发现很多存储位置已经有数据了(哈希冲突)
2. 如果为了避免发生哈希冲突,增大数组容量,就会导致空间利用率不高
```

```
而加载因子就是表示 Hash 表中元素的填满程度

加载因子 = 填入表中的元素个数 / 散列表的长度

加载因子越大,填满的元素越多,空间利用率越高,但发生哈希冲突的机会就变大了

加载因子越小,填满的元素越少,冲突发生的机会变少了,但是空间浪费的比较多,而且还会提高扩容 rehash 的操作次数
```

```
冲突的机会越大，说明需要查找的数据还需要通过另一个途径查找，这样查找的成本就越高。因此，必须在“冲突的机会”与“空间利用率”之间，寻找一种平衡与折衷。

所以我们也能知道，影响查找效率的因素主要有这几种：

	1. 散列函数是否可以将哈希表中的数据均匀地散列？
	2. 怎么处理冲突？
	3. 哈希表的加载因子怎么选择？
```

针对问题3 做出解答

2.为什么 HashMap 加载因子一定是 0.75 ? 而不是 0.8 , 0.6 ?