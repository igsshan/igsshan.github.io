# Map 集合

###### 注: 先了解一波.什么是哈希表?什么是哈希冲突?如何处理哈希冲突?

### 1.什么是哈希表

```html
	哈希表 (hash table ,也叫散列表)  是根据关键码值( key value) 而直接进行访问的数据结构,也就是说,它通过把关键码值映射到表中一个位置来访问记录,以加快查找的速度.这个映射函数也叫散列函数,存放记录的数组也叫散列表.
	记录的存储位置 = f(key)
	这里的对应关系 f 称为散列函数,又称为哈希 ( Hash函数) ,采用散列技术将记录存储在一块连续的存储空间中,这块连续的存储空间称为散列表或者哈希表(Hash table)
	哈希表 hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。
	这个映射过程称为哈希造表或者散列，这个映射函数f(key)即为哈希函数也叫散列函数，通过哈希函数得到的存储位置称为哈希地址或散列地址.
	（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）
    而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。
```

举个例子，有一组数据：[19,24,6,33,51,15]，我们用散列存储的方式将其存储在一个长度为11的数组中。采用**除留取余法**，将这组数据分别模上数组的长度（即f(key)=key % 11），以余数作为该元素在数组中的存储的位置。则会得到一个如下图所示的哈希表：

![1627286691644](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627286691644.png)此时，如果我们想从这个表中找到值为15的元素，只需要将15模上11即可得到15在数组中的存储位置。可见哈希表对于查找元素的效率是非常高的。

### 2.什么是哈希冲突

```html
对于不同的关键字,可能得到同一个哈希地址,即 key1 != key2,而 f(key1) =f(key2) ,对于这种现象被称为哈希冲突,也叫 哈希碰撞.
```

一般情况下，哈希冲突只能尽可能的减少，但不可能完全避免。因为哈希函数是从关键字集合到地址集合的映射，通常来说关键字集合比较大，它的元素理论上包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。这就导致了哈希冲突的必然性。

#### (1).如何减少哈希冲突?

尽管哈希冲突不可避免，但是我们也要尽可能的减少哈希冲突的出现。一个好的哈希函数可以有效的减少哈希冲突的出现。那什么样的哈希函数才是一个好的哈希函数呢？通常来说，一个好的哈希函数对于关键字集合中的任意一个关键字，经过这个函数映射到地址集合中任何一个集合的概率是相等的。

##### 常用的构造哈希函数的方法有以下几种：

（1）除留取余法

```
取关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址。即：f(key)=key % p, p≤m;
```

##### （2）直接定址法

```
直接定址法是指取关键字或关键字的某个线性函数值为哈希地址。即： f(key)=key 或者 f(key)=a*key+b
```

##### （3）数字分析法

```
假设关键字是以为基的数（如以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可以选取关键字的若干位数组成哈希表。
```

当然，除了上边列举的几种方法，还有很多种选取哈希函数的方法，就不一一列举了。我们只要知道，选取合适的哈希函数可以有效减少哈希冲突即可。

#### (2).如何处理哈希冲突

虽然我们可以通过选取好的哈希函数来减少哈希冲突，但是哈希冲突终究是避免不了的。那么，碰到哈希冲突应该怎么处理呢？接下来我们来介绍几种处理哈希冲突的方法。

##### （1）开放定址法

```
开放定址法是指当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。
我们以本节开头的例子来讲解开放定址法是如何处理冲突的。72模11后得到6，而此时6的位置已经被其他元素占用了，那么将6加1得到7，
此时发现7的位置也被占用了，那就再加1得到下一个地址为8，而此时8仍然被占用，再接着加1得到9，此时9处为空，则将72存入其中，即得到如下哈希表
```

![1627287699160](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627287699160.png)

像上边的这种探测方法称为**线性探测再散列**。当然除了线性探测再散列之外还有二次探测再散列，探测地址的方式为原哈希地址加上d (d= ±12±1^2±12、±22±2^2±22、±32±3^2±32......±m2±m^2±m2)，经过二次探测再散列后会得到求得72的哈希地址为5，存储如下图所示：

![1627287724552](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627287724552.png)

##### （2）再哈希法

再哈希法即选取若干个不同的哈希函数，在产生哈希冲突的时候计算另一个哈希函数，直到不再发生冲突为止。

##### （3）建立公共溢出区

专门维护一个溢出表，当发生哈希冲突时，将值填入溢出表。

##### （4）链地址法

链地址法是指在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储。也就是凡是哈希地址为**i**的元素都插入到同一个链表中，元素插入的位置可以是表头（**头插法**），也可以是表尾（**尾插法**）。我们以仍然以[19,24,6,33,51,15,25,72] 这一组数据为例，用链地址法来进行哈希冲突的处理，得到如下图所示的哈希表：

![1627288364813](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627288364813.png)

我们可以向这组数据中再添加一些元素，得到一组新的数据[19,24,6,33,51,15,25,72,37,17,4,55,83]。使用链地址法得到如下哈希表：

![1627288384350](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627288384350.png)![1627288384527](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627288384527.png)

#### (3).链地址法的弊端与优化

HashMap就是基于链地址法的哈希表结构。虽然链地址法是一种很好的处理哈希冲突的方法，但是在一些极端情况下链地址法也会出现问题。举个例子，我们现在有这样一组数据：[48,15,26,4,70,82,59]。我们将这组数据仍然散列存储到长度为11的数组中，此时则得到了如下的结果：

![1627288452559](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627288452559.png)

可以发现，此时的哈希表俨然已经退化成了一个链表，当我们在这样的数据结构中去查找某个元素的话，时间复杂度又变回了o(n)。这显然不符合我们的预期。因此，当哈希表中的链表过长时就需要我们对其进行优化。我们知道，二叉查找树的查询效率是远远高于链表的。因此，当哈希表中的链表过长时我们就可以把这个链表变成一棵红黑树。上面的一组数据优化后可得到如下结果：

![1627288482515](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627288482515.png)

红黑树是一个可以自平衡的二叉查找树。它的查询的时间复杂度为o(lgn)。通过这样的优化可以提高哈希表的查询效率。

#### (4).哈希表的扩容与Rehash

在哈希表长度不变的情况下，随着哈希表中插入的元素越来越多，发生哈希冲突的概率会越来越大，相应的查找的效率就会越来越低。这意味着影响哈希表性能的因素除了哈希函数与处理冲突的方法之外，还与哈希表的**装填因子**大小有关。

```
我们将哈希表中元素数与哈希表长度的比值称为装填因子.
装填因子 α = 哈希表中元素数/哈希表长度
```

​		很显然，**α**的值越小哈希冲突的概率越小，查找时的效率也就越高。而减小**α**的值就意味着降低了哈希表的使用率。显然这是一个矛盾的关系，不可能有完美解。为了兼顾彼此，装填因子的最大值一般选在0.65~0.9之间。

​		比如HashMap中就将装填因子定为0.75。一旦HashMap的装填因子大于0.75的时候，为了减少哈希冲突，就需要对哈希表进行**扩容**操作。比如我们可以将哈希表的长度扩大到原来的2倍。

​		这里我们应该知道，扩容并不是在原数组基础上扩大容量，而是需要申请一个长度为原来2倍的新数组。因此，扩容之后就需要将原来的数据从旧数组中重新散列存放到扩容后的新数组。这个过程我们称之为**Rehash**。

​		接下来我们仍然以[19,24,6,33,51,15,25,72,37,17,4,55,83]这组数据为例来演示哈希表扩容与Rehash的过程。假设哈希表的初始长度为11，装载因子的最大值定位0.75，扩容前的数据插入如下图所示：

![1627288850202](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627288850202.png)

当我们插入第9个元素的时候发现此时的装填因子已经大于了0.75，因此触发了扩容操作。为了方便画图，这里将数组长度扩展到了18。扩容后将[19,24,6,33,51,15,25,72,37,17,4,55,83]这组数据重新散列，会得到如下图所示的结果：

![1627288881896](C:\Users\igsshan\AppData\Roaming\Typora\typora-user-images\1627288881896.png)

可以看到扩容前后元素存储位置大相径庭。Rehash的操作将会重新散列扩容前已经存储的数据，这一操作涉及大量的元素移动，是一个非常消耗性能的操作。因此，在开发中我们应该尽量避免Rehash的出现。比如，可以预估元素的个数，事先指定哈希表的长度，这样可以有效减少Rehash。
